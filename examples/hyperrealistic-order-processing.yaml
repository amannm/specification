# yaml-language-server: $schema=../schema/workflow.yaml
document:
  dsl: '1.0.0'
  namespace: business
  name: hyperrealistic-order-processing
  version: '0.3.0'
input:
  from:
    order: .order
  schema:
    format: json
    document:
      type: object
      required: [order]
      properties:
        order:
          type: object
use:
  secrets:
    - SHIPPING_TOKEN
    - ANALYTICS_TOKEN
    - INVOICE_TOKEN
  authentications:
    shippingApi:
      bearer:
        use: SHIPPING_TOKEN
    paymentService:
      oauth2:
        authority: https://api.stripe.com
        endpoints:
          token: /oauth/token
        grant: client_credentials
        client:
          id: stripe-client-id
          secret: stripe-client-secret
    salesforce:
      oauth2:
        authority: https://login.salesforce.com
        endpoints:
          token: /services/oauth2/token
        grant: client_credentials
        client:
          id: salesforce-client-id
          secret: salesforce-client-secret
    analyticsApi:
      bearer:
        use: ANALYTICS_TOKEN
    loyaltyService:
      oauth2:
        authority: https://api.smile.io
        endpoints:
          token: /oauth/token
        grant: client_credentials
        client:
          id: loyalty-client-id
          secret: loyalty-client-secret
  errors:
    itemOutOfStock:
      type: https://ecommerce.example.com/errors/out-of-stock
      status: 409
      title: Item Out of Stock
    deliveryTimeout:
      type: https://ecommerce.example.com/errors/delivery-timeout
      status: 504
      title: Delivery Timeout
    paymentDeclined:
      type: https://ecommerce.example.com/errors/payment-declined
      status: 402
      title: Payment Declined
schedule:
  on:
    one:
      with:
        type: com.ecommerce.events.order.placed.v2
        data: ${ .orderId != null }
do:
  - initializeContext:
      set:
        order: ${ $workflow.input.order }
  - parallelPreProcessing:
      fork:
        branches:
          - verifyCustomerInfo:
              call: openapi
              with:
                document:
                  endpoint: https://api.salesforce.com/openapi.yaml
                operationId: validateCustomer
                parameters:
                  customerId: ${ $context.order.customer.id }
              output:
                as: .customerInfo
          - validateShippingAddress:
              call: openapi
              with:
                document:
                  endpoint: https://maps.googleapis.com/openapi.yaml
                operationId: verifyAddress
                parameters:
                  address: ${ $context.order.shippingAddress }
              output:
                as: .validatedAddress
          - applyCoupons:
              call: http
              with:
                method: post
                endpoint:
                  uri: https://api.shopify.com/discounts/apply
                headers:
                  content-type: application/json
                body:
                  orderId: ${ $context.order.id }
                  coupons: ${ $context.order.coupons }
              output:
                as: .couponResult
          - calculateTaxes:
              call: openapi
              with:
                document:
                  endpoint: https://api.avalara.com/openapi.yaml
                operationId: computeTaxes
                parameters:
                  orderId: ${ $context.order.id }
                  items: ${ $context.order.items }
              output:
                as: .taxes
          - publishOrderCreated:
              call: asyncapi
              with:
                document:
                  endpoint: https://confluent.cloud/asyncapi.json
                operation: publishOrderCreated
                protocol: kafka
                message:
                  payload:
                    order: ${ $context.order }
          - checkInventory:
              call: openapi
              with:
                document:
                  endpoint: https://api.sap.com/inventory/openapi.json
                operationId: checkInventory
                parameters:
                  ids: ${ $context.order.items[*].id }
              output:
                as: .inventory
  - handleInventory:
      switch:
        - available:
            when: ${ all($context.inventory[*].status == 'available') }
            then: assessRisk
        - unavailable:
            when: ${ any($context.inventory[*].status == 'unavailable') }
            then: startManufacturing
  - startManufacturing:
      call: openapi
      with:
        document:
          endpoint: https://api.siemens.com/opcenter/openapi.yaml
        operationId: createWorkOrder
        parameters:
          orderId: ${ $context.order.id }
          items: ${ $context.order.items }
      then: waitForManufacturing
  - waitForManufacturing:
      listen:
        to:
          one:
            with:
              type: com.manufacturing.events.workorder.completed.v1
              data: ${ .orderId == $context.order.id }
      timeout:
        after:
          days: 2
      then: updateInventoryAfterManufacturing
  - updateInventoryAfterManufacturing:
      call: openapi
      with:
        document:
          endpoint: https://api.sap.com/inventory/openapi.json
        operationId: updateStock
        parameters:
          ids: ${ $context.order.items[*].id }
      then: assessRisk
  - assessRisk:
      call: openapi
      with:
        document:
          endpoint: https://api.riskified.com/openapi.yaml
        operationId: evaluateOrderRisk
        parameters:
          orderId: ${ $context.order.id }
      then: initiatePayment
  - initiatePayment:
      try:
        - attemptCharge:
            call: http
            with:
              method: post
              endpoint:
                uri: https://api.stripe.com/v1/payment_intents
                authentication:
                  use: paymentService
              headers:
                content-type: application/x-www-form-urlencoded
              body:
                amount: ${ $context.order.total * 100 }
                currency: usd
                customer: ${ $context.order.customer.stripeId }
      catch:
        errors:
          with:
            status: 402
        do:
          - notifyPaymentFailure:
              run:
                container:
                  image: notifications-cli:1.0
                  command: send
                  environment:
                    EMAIL: ${ $context.order.customer.email }
                    TEMPLATE: payment-failed
          - raisePaymentDeclined:
              raise:
                error: paymentDeclined
      then: awaitPaymentConfirmation
  - awaitPaymentConfirmation:
      call: asyncapi
      with:
        document:
          endpoint: https://confluent.cloud/asyncapi.json
        operation: paymentProcessed
        protocol: kafka
        subscription:
          filter: ${ .orderId == $context.order.id }
          consume:
            amount: 1
      then: packageItems
  - packageItems:
      for:
        each: item
        in: $context.order.items
      do:
        - pack:
            run:
              container:
                image: packing-service:latest
                command: ${ "pack \($item.id)" }
                name: ${ "pack-\($item.id)-\($workflow.id)" }
                lifetime:
                  cleanup: eventually
                  after:
                    minutes: 10
      then: createShipment
  - createShipment:
      call: openapi
      with:
        document:
          endpoint: https://api.fedex.com/openapi.yaml
        operationId: createShipment
        parameters:
          orderId: ${ $context.order.id }
        redirect: true
        authentication:
          use: shippingApi
      then: scheduleWarehouseTransfer
  - scheduleWarehouseTransfer:
      call: openapi
      with:
        document:
          endpoint: https://api.fedex.com/openapi.yaml
        operationId: routeToWarehouse
        parameters:
          orderId: ${ $context.order.id }
      then: waitForWarehousePickup
  - waitForWarehousePickup:
      listen:
        to:
          one:
            with:
              type: com.logistics.events.warehouse.pickedUp.v1
              data: ${ .orderId == $context.order.id }
      timeout:
        after:
          hours: 4
      then: startShipping
  - startShipping:
      run:
        workflow:
          namespace: shipping
          name: start-shipping
          version: '0.1.0'
          input:
            order: ${ $context.order }
      then: waitForShipping
  - waitForShipping:
      listen:
        to:
          one:
            with:
              type: com.shipping.events.shipped.v1
              data: ${ .orderId == $context.order.id }
      export:
        as: "$context + { shipping: .data }"
      timeout:
        after:
          hours: 24
      then: notifyCustomer
  - notifyCustomer:
      fork:
        branches:
          - updateCRM:
              call: openapi
              with:
                document:
                  endpoint: https://api.salesforce.com/openapi.yaml
                operationId: updateOrderStatus
                parameters:
                  orderId: ${ $context.order.id }
                authentication:
                  use: salesforce
          - sendConfirmation:
              run:
                container:
                  image: notifications-cli:1.0
                  command: send
                  environment:
                    EMAIL: ${ $context.order.customer.email }
                    TEMPLATE: shipped
      then: waitForDelivery
  - waitForDelivery:
      listen:
        to:
          one:
            with:
              type: com.shipping.events.delivered.v1
              data: ${ .orderId == $context.order.id }
      timeout:
        after:
          days: 7
      then: updateDeliveryStatus
  - updateDeliveryStatus:
      call: openapi
      with:
        document:
          endpoint: https://api.salesforce.com/openapi.yaml
        operationId: updateOrderStatus
        parameters:
          orderId: ${ $context.order.id }
        authentication:
          use: salesforce
      then: grantLoyaltyPoints
  - grantLoyaltyPoints:
      call: openapi
      with:
        document:
          endpoint: https://api.smile.io/openapi.yaml
        operationId: addPoints
        parameters:
          customerId: ${ $context.order.customer.id }
        authentication:
          use: loyaltyService
      then: finalizeCustomerExperience
  - finalizeCustomerExperience:
      fork:
        branches:
          - sendSatisfactionSurvey:
              run:
                container:
                  image: marketing-cli:latest
                  command: survey
                  environment:
                    EMAIL: ${ $context.order.customer.email }
          - updateAnalytics:
              call: http
              with:
                method: post
                endpoint:
                  uri: https://api.segment.com/v1/orders
                  authentication:
                    use: analyticsApi
                body:
                  orderId: ${ $context.order.id }
                  total: ${ $context.order.total }
      then: manageSupplyChain
  - manageSupplyChain:
      call: openapi
      with:
        document:
          endpoint: https://api.sap.com/supply/openapi.yaml
        operationId: analyzeDemand
        parameters:
          orderId: ${ $context.order.id }
      then: checkSupplierCapacity
  - checkSupplierCapacity:
      call: openapi
      with:
        document:
          endpoint: https://api.sap.com/supply/openapi.yaml
        operationId: checkSuppliers
        parameters:
          orderId: ${ $context.order.id }
      then: adjustProductionPlan
  - adjustProductionPlan:
      call: openapi
      with:
        document:
          endpoint: https://api.siemens.com/opcenter/openapi.yaml
        operationId: updateProductionPlan
        parameters:
          orderId: ${ $context.order.id }
          demand: ${ $context.order.total }
      then: monitorReturns
  - monitorReturns:
      listen:
        to:
          one:
            with:
              type: com.ecommerce.events.return.initiated.v1
              data: ${ .orderId == $context.order.id }
      timeout:
        after:
          days: 30
      then: processReturn
  - processReturn:
      run:
        workflow:
          namespace: returns
          name: handle-return
          version: '0.1.0'
          input:
            order: ${ $context.order }
      then: refundCustomer
  - refundCustomer:
      call: http
      with:
        method: post
        endpoint:
          uri: https://api.stripe.com/v1/refunds
          authentication:
            use: paymentService
        headers:
          content-type: application/x-www-form-urlencoded
        body:
          payment_intent: ${ $context.order.paymentIntent }
      then: postRefundActions
  - postRefundActions:
      fork:
        branches:
          - updateCRMReturn:
              call: openapi
              with:
                document:
                  endpoint: https://api.salesforce.com/openapi.yaml
                operationId: updateOrderStatus
                parameters:
                  orderId: ${ $context.order.id }
                authentication:
                  use: salesforce
          - updateAccounting:
              call: openapi
              with:
                document:
                  endpoint: https://api.quickbooks.com/openapi.yaml
                operationId: recordRefund
                parameters:
                  orderId: ${ $context.order.id }
          - updateStock:
              call: openapi
              with:
                document:
                  endpoint: https://api.sap.com/inventory/openapi.json
                operationId: restock
                parameters:
                  ids: ${ $context.order.items[*].id }
          - notifySuppliers:
              call: openapi
              with:
                document:
                  endpoint: https://api.alibaba.com/openapi.yaml
                operationId: notifyReturn
                parameters:
                  orderId: ${ $context.order.id }
                  items: ${ $context.order.items }
      then: emitCompletion
  - emitCompletion:
      emit:
        event:
          with:
            source: https://ecommerce.example.com
            type: com.ecommerce.events.order.completed.v2
            data:
              orderId: ${ $context.order.id }
      then: finalEnterpriseProcesses
  - finalEnterpriseProcesses:
      do:
        - enterpriseParallel:
            fork:
              branches:
                - updateERP:
                    call: openapi
                    with:
                      document:
                        endpoint: https://api.sap.com/erp/openapi.yaml
                      operationId: updateOrder
                      parameters:
                        orderId: ${ $context.order.id }
                - generateInvoice:
                    run:
                      container:
                        image: invoicing-cli:latest
                        command: ${ "generate-invoice \($context.order.id)" }
                        environment:
                          INVOICE_TOKEN: ${ $secrets.INVOICE_TOKEN }
                        lifetime:
                          cleanup: eventually
                          after:
                            minutes: 5
                - notifyCompliance:
                    call: http
                    with:
                      method: post
                      endpoint:
                        uri: https://api.onetrust.com/report
                      headers:
                        content-type: application/json
                      body:
                        orderId: ${ $context.order.id }
                        total: ${ $context.order.total }
                - recordAudit:
                    run:
                      container:
                        image: audit-cli:latest
                        command: record
                        environment:
                          ORDER: ${ $context.order.id }
                - evaluateLoyaltyStatus:
                    set:
                      loyaltyStatus: "${ $context.order.total > 1000 ? 'gold' : 'standard' }"
                - updateDataWarehouse:
                    run:
                      workflow:
                        namespace: analytics
                        name: data-warehouse-ingest
                        version: "0.1.0"
                        input:
                          order: ${ $context.order }
        - sendMarketing:
            fork:
              branches:
                - sendPromoEmail:
                    run:
                      container:
                        image: marketing-cli:latest
                        command: email
                        environment:
                          TO: ${ $context.order.customer.email }
                          TEMPLATE: upsell
                - sendPromoSMS:
                    run:
                      container:
                        image: marketing-cli:latest
                        command: sms
                        environment:
                          PHONE: ${ $context.order.customer.phone }
                          TEMPLATE: upsell
                - updateAdCampaign:
                    call: openapi
                    with:
                      document:
                        endpoint: https://ads.google.com/openapi.yaml
                      operationId: recordConversion
                      parameters:
                        campaignId: 42
                        orderId: ${ $context.order.id }
                - updateCustomerSegmentation:
                    call: openapi
                    with:
                      document:
                        endpoint: https://api.hubspot.com/openapi.yaml
                      operationId: updateSegment
                      parameters:
                        customerId: ${ $context.order.customer.id }
                        segment: ${ $context.loyaltyStatus }
        - orchestrateProcurement:
            call: grpc
            with:
              proto:
                endpoint: file://protos/procurement.proto
              service:
                name: ProcurementApi.Manager
                host: sap-procurement
                port: 5021
              method: UpdateDemand
              arguments:
                id: ${ $context.order.id }
                items: ${ $context.order.items }
        - archiveOrder:
            run:
              container:
                image: tools-cli:latest
                command: archive
                environment:
                  ORDER: ${ $context.order.id }
                  STORAGE: cold
      then: end
  - raiseDeliveryTimeout:
      raise:
        error: deliveryTimeout
      then: end
  - raiseManufacturingTimeout:
      raise:
        error:
          type: https://ecommerce.example.com/errors/manufacturing-timeout
          status: 504
          title: Manufacturing Timeout
      then: end
  - raiseShippingTimeout:
      raise:
        error:
          type: https://ecommerce.example.com/errors/shipping-timeout
          status: 504
          title: Shipping Timeout
      then: end
timeout:
  after:
    hours: 2
